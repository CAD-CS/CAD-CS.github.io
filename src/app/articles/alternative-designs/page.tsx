import { Metadata } from "next";

export const metadata: Metadata = {
  title: 'Alternative Designs',
};

export default function AlternativeDesigns() {
  return (
    <article>
      <h1>Monads, Forks, And Hooks: Alternative Design Patterns In Non-Object Oriented Languages</h1>
      <hr></hr>
      <p>From the Composite pattern to the Singleton pattern, a wide variety of design patterns have emerged over the decades. For the purposes of this article, they can be broadly categorized into three groups: structural, behavioral, and creational. Each of these categories relates directly or indirectly to object-oriented concepts/principles, and the patterns themselves rely on the OOP tools provided by programming languages for their implementation. The composite pattern (structural) is a textbook example of polymorphism. Both the observer pattern (behavioral) and the abstract factory pattern (creational) use objects and classes as their building blocks. Design patterns significantly streamline and standardize software development, freeing up crucial time for developers to focus on designing and developing novel components of their software. In other words, developers don't need to reinvent the wheel every time they embark on a new project. However, design patterns are not unique to OOP. These patterns arise when developers encounter similar classes of problems. In this article, we will investigate three non-OOP patterns: one from the world of functional programming and two from the array programming language family. The Monad is the functional programming version of a design pattern. The basic idea of a monad is to allow developers to chain operations. Each operation can be linked together with a bind operator, which feeds the output of one operation into the input of another. Along the way, the bind operator performs additional actions to modify the output of the first operation before passing it to the second. In essence, using monads formalizes function composition. Each monad has its unique bind operator suited to its needs. Examples of monads include the failure monad and the list monad. The failure monad is used when an operation in a sequence can fail. If this occurs, the bind operator returns early without continuing. The list monad is used when an operation returns multiple results, and each result needs to be fed into the next operation. For example, given a single number n, an operation might create a list of n numbers, which would then need to be normalized.  The hook and fork patterns are two patterns found in the array programming language family, specifically in APL and its descendants. These patterns are a special type of function composition supported by the compiler, making them language-specific design patterns rather than the more abstract patterns discussed earlier. Using array programming notation, a hook looks like: (u v) y. In more traditional notation, it is u(y, v(y)). In English, you first apply function v to argument y, and then input the result into function u alongside the original value. For example, the expression n times (n + 1) can be easily represented in a single expression using the built-in operators found in APL and J without needing to create a user-defined function. A fork is a similar idea: (f g h) y, which is equivalent to g(f(y), h(y)). This pattern is perfect for finding the mean value of a list. Design patterns emerge wherever there is a healthy ecosystem of developers collaborating and publishing their work. As can be seen from the wealth of patterns that have arisen for OOP, functional, and array programming, these paradigms are no different. As functional and array programming gain more traction and popularity, more unique and domain-specific patterns will arise.</p>
    </article>
  );
}